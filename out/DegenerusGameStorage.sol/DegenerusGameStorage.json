{"abi":[{"type":"function","name":"deployTimestamp","inputs":[],"outputs":[{"name":"","type":"uint48","internalType":"uint48"}],"stateMutability":"view"},{"type":"function","name":"gameState","inputs":[],"outputs":[{"name":"","type":"uint8","internalType":"uint8"}],"stateMutability":"view"},{"type":"function","name":"level","inputs":[],"outputs":[{"name":"","type":"uint24","internalType":"uint24"}],"stateMutability":"view"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"deployTimestamp()":"607ad0d7","gameState()":"d1f9c24d","level()":"6fd5ae15"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.30+commit.73712a01\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"deployTimestamp\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameState\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"level\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Burnie Degenerus\",\"details\":\"ARCHITECTURE OVERVIEW ----------------------------------------------------------------------------- This contract defines the canonical storage layout for the Degenerus game ecosystem. It is inherited by:   - DegenerusGame (main contract, holds actual state)   - DegenerusGameBondModule (delegatecall module)   - DegenerusGameEndgameModule (delegatecall module)   - DegenerusGameJackpotModule (delegatecall module)   - DegenerusGameMintModule (delegatecall module) DELEGATECALL PATTERN: When DegenerusGame calls `module.delegatecall(...)`, the module's code executes in the context of DegenerusGame's storage. This means:   1. Storage slots MUST match exactly between the main contract and all modules.   2. This contract ensures slot alignment by providing a single source of truth.   3. Never add storage variables to module contracts \\u2014 they would collide with game storage. STORAGE SLOT LAYOUT (EVM assigns slots sequentially): ----------------------------------------------------------------------------- +-----------------------------------------------------------------------------+ | SLOT 0 (32 bytes) \\u2014 Timing, Batching, FSM                                   | +-----------------------------------------------------------------------------+ | [0:6]   levelStartTime           uint48   Timestamp when level opened       | | [6:12]  dailyIdx                 uint48   Monotonic day counter             | | [12:18] rngRequestTime           uint48   When last VRF request was fired   | | [18:22] airdropMapsProcessedCount uint32  Maps handled in current batch     | | [22:26] airdropIndex             uint32   Index into pendingMapMints        | | [26:29] level                    uint24   Current game level (1-indexed)    | | [29:31] lastExterminatedTrait    uint16   Last cleared trait (420=sentinel) | | [31:32] gameState                uint8    FSM: 0=presale,1=setup,2=mint,3=burn (86=gameover) | +-----------------------------------------------------------------------------+   Total: 6+6+6+4+4+3+2+1 = 32 bytes \\u2713 (perfectly packed) +-----------------------------------------------------------------------------+ | SLOT 1 (32 bytes) \\u2014 Cursors, Counters, Boolean Flags                        | +-----------------------------------------------------------------------------+ | [0:4]   traitRebuildCursor       uint32   Cursor for trait count reseeding  | | [4:8]   airdropMultiplier        uint32   Bonus multiplier (scaled)         | | [8:9]   jackpotCounter           uint8    Jackpots processed this level     | | [9:10]  earlyBurnPercent         uint8    Previous pool % in early burn     | | [10:11] levelJackpotPaid         bool     Level jackpot executed flag       | | [11:12] lastPurchaseDay          bool     Prize target met flag             | | [12:13] decWindowOpen            bool     Decimator window latch            | | [13:14] earlyBurnBoostArmed      bool     Boost armed for next jackpot      | | [14:15] rngLockedFlag            bool     Waiting for VRF fulfillment       | | [15:16] rngFulfilled             bool     VRF lifecycle tracker             | | [16:17] traitCountsSeedQueued    bool     Initial traits staged flag        | | [17:18] decimatorHundredReady    bool     Level %100 special primed         | | [18:19] exterminationInvertFlag  bool     Exterminator bonus inversion      | | [19:20] bondMaintenancePending   bool     Bond maintenance needed flag      | | [20:21] mapJackpotType          uint8    0=none, 1=daily, 2=purchase        | | [21:22] presaleJackpotQueued    bool     Legacy presale queue flag         | | [22:32] <padding>                         10 bytes unused                   | +-----------------------------------------------------------------------------+   Total: 4+4+1+1+1+1+1+1+1+1+1+1+1+1+1+1 = 21 bytes (11 bytes padding) +-----------------------------------------------------------------------------+ | SLOT 2 (32 bytes) \\u2014 Price                                                   | +-----------------------------------------------------------------------------+ | [0:16]  price                    uint128  Current mint price in wei         | | [16:32] <padding>                         16 bytes unused                   | +-----------------------------------------------------------------------------+ SLOTS 3+ \\u2014 Full-width variables, arrays, and mappings ----------------------------------------------------------------------------- Each uint256, array length, or mapping root occupies its own slot. Dynamic arrays: length at slot N, data at keccak256(N). Mappings: value at keccak256(key . slot). SECURITY CONSIDERATIONS ----------------------------------------------------------------------------- 1. SLOT STABILITY: Never reorder, remove, or change types of existing variables.    Append-only additions are safe for non-upgradeable contracts. 2. DELEGATECALL SAFETY: All modules inherit this exact layout. If a module    declared its own storage variables, they would occupy the same slots as    game data, causing catastrophic corruption. 3. ACCESS CONTROL: All variables are `internal`, preventing external reads.    Public getters in DegenerusGame expose only what's needed. 4. INITIALIZATION: Default values are set inline. For critical variables:    - levelStartTime = type(uint48).max (sentinel: game not started)    - lastExterminatedTrait = 420 (sentinel: no trait exterminated)    - gameState = 0 (presale state)    - decWindowOpen = true (decimator window starts open)    - rngFulfilled = true (no pending request at deploy)    - price = 0.025 ether (initial mint price)    - lastPrizePool = 125 ether (bootstrap value for % calculations) 5. OVERFLOW PROTECTION: Solidity 0.8+ provides automatic overflow checks.    `unchecked` blocks in modules are intentional optimizations for safe ops. 6. MAPPING COLLISION: Mappings use keccak256(key . slot), making collisions    computationally infeasible. The traitBurnTicket nested mapping uses    keccak256(traitId . keccak256(level . slot)) for data location. UPGRADE NOTES ----------------------------------------------------------------------------- This contract is NOT upgradeable (no proxy pattern). However, if future versions are deployed, they MUST preserve this exact layout to allow state migration or fork compatibility. Document any additions here. VARIABLE DOCUMENTATION ----------------------------------------------------------------------------- See inline comments for each variable group below.\",\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"PRICE_COIN_UNIT\":{\"details\":\"Conversion factor for BURNIE token amounts.      BURNIE uses 18 decimals, so 1000 BURNIE = 1e21 base units.      Used in price calculations: price / PRICE_COIN_UNIT = BURNIE per mint.\"},\"affiliateProgramAddr\":{\"details\":\"DEPRECATED: Cached affiliate program address (now a constant in each contract).      Kept for storage layout stability; do not repurpose or remove in-place.      See ContractAddresses.AFFILIATE instead.\"},\"airdropIndex\":{\"details\":\"Index into the pendingMapMints array for batched airdrop processing.      Allows gas-bounded iteration: process N mints, save progress, continue      in subsequent transactions until all airdrops are complete.      SECURITY: Batch processing prevents DoS from large airdrop queues.\"},\"airdropMapsProcessedCount\":{\"details\":\"Count of map mints processed within the current airdrop batch.      Reset to 0 when advancing to a new player in pendingMapMints.      Used with playerMapMintsOwed to track partial batch completion.      SECURITY: uint32 supports up to ~4B mints per player \\u2014 far exceeds      realistic airdrop volumes.\"},\"airdropMultiplier\":{\"details\":\"Airdrop bonus multiplier (scaled integer representation).      Applied during map mint calculations for promotional events.\"},\"bafHundredPool\":{\"details\":\"Reserved pool for the BAF (Burn and Flip?) 100-level special.      Similar to decimatorHundredPool for a different milestone reward.\"},\"bondGameOver\":{\"details\":\"True once bondPool has been flushed to bonds contract.      Marks end-of-game state for bond obligations.      Once true, bond claims go directly to bonds contract.\"},\"bondMaintenancePending\":{\"details\":\"True while bond maintenance requires dedicated advanceGame calls.      Set when bond operations are pending; cleared when complete.      Prevents normal game progression until bonds are serviced.\"},\"bondPool\":{\"details\":\"ETH dedicated to bond obligations.      Lives in game contract until bondGameOver flushes to bonds.      Tracked separately from prize pools for clean accounting.\"},\"bonds\":{\"details\":\"DEPRECATED: Address of the DegenerusBonds contract (now a constant in each contract).      Kept for storage layout stability; do not repurpose or remove in-place.      See ContractAddresses.BONDS instead.\"},\"claimablePool\":{\"details\":\"Aggregate ETH liability across all claimableWinnings entries.      Used for solvency checks: game must hold >= claimablePool ETH.      INVARIANT: claimablePool == sum(claimableWinnings[*])      Maintained by crediting/debiting both in tandem.\"},\"claimableWinnings\":{\"details\":\"ETH claimable by players from jackpot winnings.      Credited by jackpot logic; withdrawn via claim function.      SECURITY: Pull pattern \\u2014 players withdraw their own funds.      Prevents reentrancy by separating credit from transfer.\"},\"currentPrizePool\":{\"details\":\"Active prize pool for the current level.      Accumulated from mint fees and distributed via jackpots.\"},\"dailyBurnCount\":{\"details\":\"Per-day trait hit counters used for jackpot trait selection.      Index layout: [0-7] symbols, [8-15] colors, [16-79] combined traits.      80 elements * 4 bytes = 320 bytes = 10 storage slots (packed).      SECURITY: Fixed-size array prevents unbounded growth.      uint32 per counter supports ~4B burns per trait per day.\"},\"dailyIdx\":{\"details\":\"Monotonically increasing \\\"day\\\" counter derived from block timestamps.      Incremented during game progression; used to key RNG words and track      daily jackpot eligibility. NOT tied to calendar days \\u2014 it's game-relative.      SECURITY: uint48 allows ~281 trillion increments \\u2014 effectively unlimited.\"},\"dailyJackpotBase\":{\"details\":\"Baseline ETH allocated per daily jackpot.      Set during calcPrizePoolForLevelJackpot; consumed by payDailyJackpot.      Escalating BPS (610-1225) applied per jackpot index.\"},\"decWindowOpen\":{\"details\":\"Latch to hold decimator window open until RNG is requested.      Set true at level start; cleared when decimator phase begins.      Default true ensures first decimator window is properly gated.\"},\"decimatorHundredPool\":{\"details\":\"Reserved pool for the level-100 decimator special reward.      Accumulated separately to ensure milestone payouts are funded.\"},\"decimatorHundredReady\":{\"details\":\"True when level % 100 decimator special is primed and ready.      Milestone levels (100, 200, etc.) have special decimator rewards.\"},\"deployTimestamp\":{\"details\":\"Deployment timestamp for long-tail inactivity guard.      If game is inactive for extended period after deploy, certain      recovery mechanisms may activate.      PUBLIC: Exposed for transparency and off-chain monitoring.\"},\"earlyBurnBoostArmed\":{\"details\":\"True if the next jackpot should apply an ETH boost.      Armed when early burn percentage exceeds 60% threshold.      Consumed (set false) when the boosted jackpot is paid.\"},\"earlyBurnPercent\":{\"details\":\"Percentage of previous prize pool carried into early burn reward.      Range 0-255 (but practically 0-100%). Used for early burn bonus      calculations in the jackpot module.\"},\"exterminationInvertFlag\":{\"details\":\"Toggles inversion of exterminator bonus on certain levels.      Adds variety to extermination mechanics across levels.\"},\"gameState\":{\"details\":\"Finite State Machine for game phases:      0 = presale (RNG + flips only)      1 = setup (awaiting start or between major phases)      2 = airdrop/mint phase (purchases open)      3 = burn window (extermination phase)      86 = game over (terminal)      PUBLIC: Exposed for frontend state queries.      SECURITY: State transitions are guarded by modifiers in DegenerusGame.      Invalid state transitions revert, preventing exploitation.\"},\"jackpotCounter\":{\"details\":\"Count of jackpots processed within the current level.      Capped at 10 (JACKPOT_LEVEL_CAP in JackpotModule); triggers level      advancement when reached. Reset at level start.      SECURITY: uint8 is sufficient (max 255, only need 0-10).\"},\"lastExterminatedTrait\":{\"details\":\"The last trait ID that was exterminated this level.      420 is a sentinel value meaning \\\"no extermination yet\\\" or \\\"timed out\\\".      Valid trait IDs are 0-255, so 420 is unambiguously a sentinel.      DESIGN: Easter egg reference (420). Functional as a clear sentinel.\"},\"lastPrizePool\":{\"details\":\"Prize pool snapshot from the previous level.      Used as denominator for early burn percentage calculations.      Bootstrap value of 125 ether ensures non-zero denominator at launch.      SECURITY: Never zero after initialization, preventing division by zero.\"},\"lastPurchaseDay\":{\"details\":\"True once the prize target is met for current level.      When true, next tick skips normal daily/jackpot prep and proceeds      to burn window. Allows early level completion on high activity.\"},\"lastPurchaseDayFlipTotal\":{\"details\":\"Total coinflip deposits during lastPurchaseDay = true (current level).      Used for jackpot sizing adjustments based on flip activity.\"},\"lastPurchaseDayFlipTotalPrev\":{\"details\":\"Previous level's lastPurchaseDay coinflip deposits.      Compared with current to detect activity trends (doubled/halved).      Affects reward pool retention percentage in jackpot calculations.\"},\"level\":{\"details\":\"Current game level (1-indexed). Levels progress through purchase and      burn phases, with jackpots at various milestones.      PUBLIC: Exposed for frontend/analytics. Read-only externally.      SECURITY: uint24 supports ~16M levels \\u2014 game would take millennia      to overflow at realistic progression rates.\"},\"levelExterminators\":{\"details\":\"Per-level exterminator addresses (key = level).      Records who performed the final extermination for each level.      Used for cosmetic/trophy purposes.\"},\"levelJackpotPaid\":{\"details\":\"True once the level jackpot has been executed for the      current purchase phase. Prevents double-payment.      SECURITY: Critical for jackpot integrity. Reset at level transition.\"},\"levelStartTime\":{\"details\":\"Timestamp when the current level opened for purchase phase.      Initialized to uint48.max as a sentinel indicating \\\"game not started\\\".      Used for inactivity guard timing and purchase-phase weekly jackpots.      SECURITY: uint48 holds timestamps until year 8.9 million \\u2014 safe for any      realistic game lifetime. Overflow is not a concern.\"},\"mapJackpotType\":{\"details\":\"Unified MAP jackpot pending type. Daily and purchase MAP jackpots are      mutually exclusive, so a single enum tracks which (if any) is queued:      0 = none, 1 = daily, 2 = purchase.      Timeout is computed on-the-fly from jackpotCounter >= JACKPOT_LEVEL_CAP.\"},\"mapJackpotUnits1\":{\"details\":\"MAP units for the pending MAP jackpot (slot 1).      For daily: units for current-level draw.      For purchase: the only units slot used.      Units are computed at scheduling time to avoid price drift.\"},\"mapJackpotUnits2\":{\"details\":\"MAP units for the pending MAP jackpot (slot 2).      For daily: units for carryover (next-level) draw.      For purchase: unused (remains 0).\"},\"mintPacked_\":{\"details\":\"Bit-packed mint history per player.      Layout defined by ETH_* constants in DegenerusGame:      - Tracks mint counts, bonuses, and eligibility flags.      - Single SLOAD/SSTORE for all mint-related player data.      SECURITY: Packing reduces gas and storage footprint.      Bit manipulation requires careful masking (done in DegenerusGame).\"},\"nextPrizePool\":{\"details\":\"Pre-funded prize pool for the next level.      Allows carryover mechanics and smooth level transitions.\"},\"pendingMapMints\":{\"details\":\"Queue of player addresses awaiting map NFT mints.      Processed in batches via airdropIndex cursor.      Dynamic array: length at slot N, data at keccak256(N).      SECURITY: Batched processing with gas budgeting prevents DoS.      Array growth is bounded by game mechanics (mint limits).\"},\"playerMapMintsOwed\":{\"details\":\"Map NFT count owed per player, consumed during batch processing.      Decremented as airdrops are processed; reaches 0 when complete.      DESIGN: Separate from pendingMapMints to allow partial batching      within a single player's owed amount.\"},\"presaleJackpotQueued\":{\"details\":\"Legacy presale jackpot queue flag (unused).      Kept for storage layout stability; do not repurpose or remove in-place.\"},\"presaleMintingEnabledFlag\":{\"details\":\"True if presale minting (tokens/maps) is enabled.\"},\"price\":{\"details\":\"Current price to mint one NFT, in wei.      uint128 supports up to ~340 undecillion wei (~3.4e20 ETH) \\u2014 far      beyond any realistic price point.      Default 0.025 ether = 25 finney = initial launch price.      SECURITY: Price updates are admin-controlled. uint128 prevents      overflow in multiplication with reasonable quantities.\"},\"questModule\":{\"details\":\"DEPRECATED: Quest module address (now a constant in each contract).      Kept for storage layout stability; do not repurpose or remove in-place.      See ContractAddresses.QUESTS instead.\"},\"rewardPool\":{\"details\":\"Aggregate ETH available for rewards (jackpots, bonuses, etc.).      Funded by mint fees and managed by jackpot distribution logic.\"},\"rngFulfilled\":{\"details\":\"Tracks VRF lifecycle; true when no pending request exists.      Default true because at deploy, no request is outstanding.      Set false when requesting, true when fulfilled.      SECURITY: Works with rngLockedFlag to ensure RNG consistency.\"},\"rngLockedFlag\":{\"details\":\"True while waiting for VRF (Chainlink) fulfillment.      Prevents duplicate RNG requests and gates state transitions      that depend on randomness.      SECURITY: Critical for RNG integrity. Prevents re-entrancy      attacks on RNG-dependent operations.\"},\"rngRequestTime\":{\"details\":\"Timestamp when the last VRF (Chainlink) request was submitted.      Used for timeout detection: if rngRequestTime + timeout < now and      rngLockedFlag is still true, the game can recover via fallback RNG.      SECURITY: Timeout mechanism prevents permanent lockup if VRF fails.\"},\"rngWordByDay\":{\"details\":\"VRF random words keyed by dailyIdx.      0 means \\\"not yet recorded\\\" (no request fulfilled for that day).      Historical words enable verifiable replay of past randomness.      SECURITY: Immutable once written; provides audit trail for RNG.\"},\"rngWordCurrent\":{\"details\":\"Latest VRF random word, or 0 if a request is pending.      Written by VRF callback; consumed by game logic for randomness.      SECURITY: 0 indicates pending state. Game logic checks rngFulfilled      flag rather than checking for non-zero to avoid edge cases.\"},\"totalFlipReversals\":{\"details\":\"Number of reverse flips purchased against current RNG word.      Tracks flip activity for jackpot sizing adjustments.\"},\"traitBurnTicket\":{\"details\":\"Nested mapping: level -> trait ID (0-255) -> array of ticket holders.      Used for jackpot winner selection: random index into trait's array.      STRUCTURE: traitBurnTicket[level][traitId] = address[]      Each burn adds the burner's address, allowing duplicate entries      (more burns = more tickets = higher win probability).      STORAGE: Slot for mapping root, then:        - keccak256(level . slot) gives the 256-element array of arrays        - Each inner array has length at its slot, data at keccak256(slot)      SECURITY: Array growth bounded by total NFT supply per level.\"},\"traitCountsSeedQueued\":{\"details\":\"True if initial trait counts were staged and await overwrite.      Used during level initialization to handle batched seeding.\"},\"traitRebuildCursor\":{\"details\":\"Progress cursor for reseeding trait counts at level start.      Used in batched trait initialization to avoid gas limits.\"},\"traitRemaining\":{\"details\":\"Remaining supply per trait ID (0-255).      Decremented on burns; used for extermination detection.      256 elements * 4 bytes = 1024 bytes = 32 storage slots (packed).      SECURITY: Fixed-size, bounded by initial supply seeding.\"},\"traitStartRemaining\":{\"details\":\"Supply per trait ID at burn phase start.      Snapshot taken at mint\\u2192burn transition; used to calculate      map vs burn ticket splits for jackpot fairness.      SECURITY: Snapshot prevents manipulation during burn phase.\"},\"trophies\":{\"details\":\"DEPRECATED: Address of standalone trophy contract (now a constant in each contract).      Kept for storage layout stability; do not repurpose or remove in-place.      See ContractAddresses.TROPHIES instead.\"},\"vault\":{\"details\":\"DEPRECATED: Address of the reward vault (now a constant in each contract).      Kept for storage layout stability; do not repurpose or remove in-place.      See ContractAddresses.VAULT instead.\"},\"vrfRequestId\":{\"details\":\"Last VRF request ID, used to match fulfillment callbacks.      Prevents processing stale or mismatched VRF responses.      SECURITY: Request ID matching prevents replay attacks on RNG.\"}},\"title\":\"DegenerusGameStorage\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Shared storage layout between DegenerusGame and its delegatecall modules.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/storage/DegenerusGameStorage.sol\":\"DegenerusGameStorage\"},\"evmVersion\":\"prague\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"details\":{\"constantOptimizer\":true,\"cse\":true,\"deduplicate\":true,\"inliner\":true,\"jumpdestRemover\":true,\"orderLiterals\":true,\"peephole\":true,\"simpleCounterForLoopUncheckedIncrement\":true,\"yul\":true,\"yulDetails\":{\"optimizerSteps\":\"dhfoDgvulfnTUtnIf:fDnTOcmuO\",\"stackAllocation\":true}},\"runs\":200},\"remappings\":[\":@arbitrum/=node_modules/@arbitrum/\",\":@chainlink/=node_modules/@chainlink/\",\":@eth-optimism/=node_modules/@chainlink/contracts/node_modules/@eth-optimism/\",\":@offchainlabs/=node_modules/@offchainlabs/\",\":@openzeppelin/=node_modules/@openzeppelin/\",\":@scroll-tech/=node_modules/@scroll-tech/\",\":@zksync/=node_modules/@zksync/\",\":erc721a/=node_modules/erc721a/\",\":hardhat/=node_modules/hardhat/\",\":solady/=node_modules/solady/\"],\"viaIR\":true},\"sources\":{\"contracts/storage/DegenerusGameStorage.sol\":{\"keccak256\":\"0x9b320af7aaad31d3f5e13494556defe6f486dcf1a3671bd00a968ea85722c495\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b7fa37b908354a14d763c71ed17ec8f16e79faa349b2fcf0dc37e3a5f164f74c\",\"dweb:/ipfs/QmaU1JST3a9a38zPJrghofJrW8n6AtNLkQR7xvU5VNQ5yU\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.30+commit.73712a01"},"language":"Solidity","output":{"abi":[{"inputs":[],"stateMutability":"view","type":"function","name":"deployTimestamp","outputs":[{"internalType":"uint48","name":"","type":"uint48"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"gameState","outputs":[{"internalType":"uint8","name":"","type":"uint8"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"level","outputs":[{"internalType":"uint24","name":"","type":"uint24"}]}],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["@arbitrum/=node_modules/@arbitrum/","@chainlink/=node_modules/@chainlink/","@eth-optimism/=node_modules/@chainlink/contracts/node_modules/@eth-optimism/","@offchainlabs/=node_modules/@offchainlabs/","@openzeppelin/=node_modules/@openzeppelin/","@scroll-tech/=node_modules/@scroll-tech/","@zksync/=node_modules/@zksync/","erc721a/=node_modules/erc721a/","hardhat/=node_modules/hardhat/","solady/=node_modules/solady/"],"optimizer":{"runs":200,"details":{"peephole":true,"inliner":true,"jumpdestRemover":true,"orderLiterals":true,"deduplicate":true,"cse":true,"constantOptimizer":true,"yul":true,"yulDetails":{"stackAllocation":true,"optimizerSteps":"dhfoDgvulfnTUtnIf:fDnTOcmuO"},"simpleCounterForLoopUncheckedIncrement":true}},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"contracts/storage/DegenerusGameStorage.sol":"DegenerusGameStorage"},"evmVersion":"prague","libraries":{},"viaIR":true},"sources":{"contracts/storage/DegenerusGameStorage.sol":{"keccak256":"0x9b320af7aaad31d3f5e13494556defe6f486dcf1a3671bd00a968ea85722c495","urls":["bzz-raw://b7fa37b908354a14d763c71ed17ec8f16e79faa349b2fcf0dc37e3a5f164f74c","dweb:/ipfs/QmaU1JST3a9a38zPJrghofJrW8n6AtNLkQR7xvU5VNQ5yU"],"license":"MIT"}},"version":1},"id":39}