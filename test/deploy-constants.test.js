import { expect } from "chai";
import fs from "node:fs";
import path from "node:path";
import hre from "hardhat";
import { getCreateAddress } from "ethers";

const DEPLOY_ORDER = [
  "ICONS_32",
  "TROPHY_SVG_ASSETS",
  "GAME_MINT_MODULE",
  "GAME_JACKPOT_MODULE",
  "GAME_BOND_MODULE",
  "GAME_ENDGAME_MODULE",
  "DGNRS",
  "BONDS",
  "COIN",
  "VAULT",
  "AFFILIATE",
  "JACKPOTS",
  "QUESTS",
  "ICON_COLOR_REGISTRY",
  "RENDERER_REGULAR",
  "RENDERER_TROPHY_SVG",
  "RENDERER_TROPHY",
  "GAMEPIECE_RENDERER_ROUTER",
  "TROPHY_RENDERER_ROUTER",
  "TROPHIES",
  "GAMEPIECES",
  "GAME",
  "ADMIN"
];

const ALL_CONSTANTS = [...DEPLOY_ORDER, "STETH_TOKEN", "LINK_TOKEN", "CREATOR"];
const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";

function renderSolidity(constants) {
  const lines = [
    "// SPDX-License-Identifier: MIT",
    "pragma solidity ^0.8.26;",
    "",
    "// AUTO-GENERATED by test/deploy-constants.test.js",
    "// Do not edit by hand; regenerate via the test.",
    "library DeployConstants {"
  ];

  for (const name of ALL_CONSTANTS) {
    const value = constants[name] || ZERO_ADDRESS;
    lines.push(`    address internal constant ${name} = ${value};`);
  }

  lines.push("}");
  lines.push("");
  return lines.join("\n");
}

async function deployAll(ethers, deployer, expected) {
  const deployed = {};
  const iconsPath = path.resolve("scripts/data/icons32Data.json");
  const iconsData = JSON.parse(fs.readFileSync(iconsPath, "utf8"));
  if (iconsData.paths?.length !== 33) throw new Error("icons32Data.json paths length mismatch");
  if (iconsData.symQ1?.length !== 8) throw new Error("icons32Data.json symQ1 length mismatch");
  if (iconsData.symQ2?.length !== 8) throw new Error("icons32Data.json symQ2 length mismatch");
  if (iconsData.symQ3?.length !== 8) throw new Error("icons32Data.json symQ3 length mismatch");

  for (const name of DEPLOY_ORDER) {
    let factory;
    let args = [];
    if (name === "ICONS_32") {
      factory = await ethers.getContractFactory("contracts/Icons32Data.sol:Icons32Data", deployer);
      args = [iconsData.paths, iconsData.diamond, iconsData.symQ1, iconsData.symQ2, iconsData.symQ3];
    } else if (name === "TROPHY_SVG_ASSETS") {
      factory = await ethers.getContractFactory("contracts/TrophySvgAssets.sol:TrophySvgAssets", deployer);
    } else if (name === "GAME_MINT_MODULE") {
      factory = await ethers.getContractFactory(
        "contracts/modules/DegenerusGameMintModule.sol:DegenerusGameMintModule",
        deployer
      );
    } else if (name === "GAME_JACKPOT_MODULE") {
      factory = await ethers.getContractFactory(
        "contracts/modules/DegenerusGameJackpotModule.sol:DegenerusGameJackpotModule",
        deployer
      );
    } else if (name === "GAME_BOND_MODULE") {
      factory = await ethers.getContractFactory(
        "contracts/modules/DegenerusGameBondModule.sol:DegenerusGameBondModule",
        deployer
      );
    } else if (name === "GAME_ENDGAME_MODULE") {
      factory = await ethers.getContractFactory(
        "contracts/modules/DegenerusGameEndgameModule.sol:DegenerusGameEndgameModule",
        deployer
      );
    } else if (name === "DGNRS") {
      factory = await ethers.getContractFactory("contracts/DegenerusBonds.sol:BondToken", deployer);
      args = ["Degenerus Bond DGNRS", "DGNRS", expected.BONDS];
    } else if (name === "BONDS") {
      factory = await ethers.getContractFactory("contracts/DegenerusBonds.sol:DegenerusBonds", deployer);
    } else if (name === "VAULT") {
      factory = await ethers.getContractFactory("contracts/DegenerusVault.sol:DegenerusVault", deployer);
    } else if (name === "COIN") {
      factory = await ethers.getContractFactory("contracts/DegenerusCoin.sol:DegenerusCoin", deployer);
    } else if (name === "AFFILIATE") {
      factory = await ethers.getContractFactory("contracts/DegenerusAffiliate.sol:DegenerusAffiliate", deployer);
    } else if (name === "JACKPOTS") {
      factory = await ethers.getContractFactory("contracts/DegenerusJackpots.sol:DegenerusJackpots", deployer);
    } else if (name === "QUESTS") {
      factory = await ethers.getContractFactory("contracts/DegenerusQuests.sol:DegenerusQuests", deployer);
    } else if (name === "ICON_COLOR_REGISTRY") {
      factory = await ethers.getContractFactory("contracts/IconColorRegistry.sol:IconColorRegistry", deployer);
    } else if (name === "RENDERER_REGULAR") {
      factory = await ethers.getContractFactory("contracts/IconRendererRegular32.sol:IconRendererRegular32", deployer);
    } else if (name === "RENDERER_TROPHY_SVG") {
      factory = await ethers.getContractFactory("contracts/IconRendererTrophy32Svg.sol:IconRendererTrophy32Svg", deployer);
    } else if (name === "RENDERER_TROPHY") {
      factory = await ethers.getContractFactory("contracts/IconRendererTrophy32.sol:IconRendererTrophy32", deployer);
    } else if (name === "GAMEPIECE_RENDERER_ROUTER") {
      factory = await ethers.getContractFactory("contracts/GamepieceRendererRouter.sol:GamepieceRendererRouter", deployer);
    } else if (name === "TROPHY_RENDERER_ROUTER") {
      factory = await ethers.getContractFactory("contracts/TrophyRendererRouter.sol:TrophyRendererRouter", deployer);
    } else if (name === "TROPHIES") {
      factory = await ethers.getContractFactory("contracts/DegenerusTrophies.sol:DegenerusTrophies", deployer);
    } else if (name === "GAMEPIECES") {
      factory = await ethers.getContractFactory("contracts/DegenerusGamepieces.sol:DegenerusGamepieces", deployer);
    } else if (name === "GAME") {
      factory = await ethers.getContractFactory("contracts/DegenerusGame.sol:DegenerusGame", deployer);
    } else if (name === "ADMIN") {
      factory = await ethers.getContractFactory("contracts/DegenerusAdmin.sol:DegenerusAdmin", deployer);
    } else {
      throw new Error(`Unknown deploy target: ${name}`);
    }

    const contract = await factory.deploy(...args);
    await contract.waitForDeployment();
    const addr = await contract.getAddress();
    expect(addr).to.equal(expected[name]);
    deployed[name] = contract;
  }

  return deployed;
}

describe("DeployConstants wiring", function () {
  it("precomputes addresses and deploys in order", async function () {
    this.timeout(120000);
    const { ethers, run } = hre;
    const [deployer, aux] = await ethers.getSigners();

    const mockStEthFactory = await ethers.getContractFactory("contracts/test/MockStETH.sol:MockStETH", aux);
    const mockStEth = await mockStEthFactory.deploy();
    await mockStEth.waitForDeployment();

    const mockLinkFactory = await ethers.getContractFactory("contracts/test/MockLink.sol:MockLink", aux);
    const mockLink = await mockLinkFactory.deploy();
    await mockLink.waitForDeployment();

    const startNonce = await deployer.getNonce();
    const expected = {};
    let nonce = startNonce;
    for (const name of DEPLOY_ORDER) {
      expected[name] = getCreateAddress({ from: deployer.address, nonce });
      nonce += 1;
    }
    expected.STETH_TOKEN = await mockStEth.getAddress();
    expected.LINK_TOKEN = await mockLink.getAddress();
    expected.CREATOR = deployer.address;

    const output = path.resolve("contracts/DeployConstants.sol");
    fs.writeFileSync(output, renderSolidity(expected), "utf8");

    await run("compile");

    const deployed = await deployAll(ethers, deployer, expected);

    const gamepieceRouter = deployed.GAMEPIECE_RENDERER_ROUTER;
    expect(await gamepieceRouter.primary()).to.equal(ZERO_ADDRESS);
    expect(await gamepieceRouter.fallbackRenderer()).to.equal(expected.RENDERER_REGULAR);

    const trophyRouter = deployed.TROPHY_RENDERER_ROUTER;
    expect(await trophyRouter.primary()).to.equal(ZERO_ADDRESS);
    expect(await trophyRouter.fallbackRenderer()).to.equal(expected.RENDERER_TROPHY);

    const bonds = deployed.BONDS;
    expect(await bonds.dgnrsToken()).to.equal(expected.DGNRS);
  });
});
