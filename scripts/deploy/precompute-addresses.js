import fs from "node:fs";
import path from "node:path";
import { getCreateAddress, isAddress } from "ethers";

function readJson(filePath) {
  const raw = fs.readFileSync(filePath, "utf8");
  return JSON.parse(raw);
}

function toAbs(p) {
  return path.isAbsolute(p) ? p : path.resolve(p);
}

function normalizeAddress(addr) {
  if (typeof addr !== "string" || !isAddress(addr)) {
    throw new Error(`Invalid address: ${addr}`);
  }
  return addr;
}

function renderSolidity(constants, order) {
  const lines = [
    "// SPDX-License-Identifier: MIT",
    "pragma solidity ^0.8.26;",
    "",
    "// AUTO-GENERATED by scripts/deploy/precompute-addresses.js",
    "// Do not edit by hand; regenerate from your deploy config.",
    "library DeployConstants {"
  ];

  for (const name of order) {
    const value = constants[name];
    if (!value) continue;
    lines.push(`    address internal constant ${name} = ${value};`);
  }

  lines.push("}");
  lines.push("");
  return lines.join("\n");
}

function main() {
  const args = process.argv.slice(2);
  const configArgIdx = args.indexOf("--config");
  const configPath = configArgIdx !== -1 ? args[configArgIdx + 1] : "scripts/deploy/deploy-config.json";
  const absConfigPath = toAbs(configPath);

  if (!fs.existsSync(absConfigPath)) {
    throw new Error(`Config not found: ${absConfigPath}`);
  }

  const config = readJson(absConfigPath);
  const deployer = normalizeAddress(config.deployer);
  const zeroAddress = "0x0000000000000000000000000000000000000000";
  const placeholder = deployer.toLowerCase() === zeroAddress;
  const startNonce = Number(config.startNonce ?? 0);
  if (!Number.isInteger(startNonce) || startNonce < 0) {
    throw new Error(`Invalid startNonce: ${config.startNonce}`);
  }

  const deployOrder = Array.isArray(config.deployOrder) ? config.deployOrder : [];
  if (deployOrder.length === 0) {
    throw new Error("deployOrder must be a non-empty array");
  }

  const constants = {};
  let nonce = startNonce;
  for (const name of deployOrder) {
    if (typeof name !== "string" || name.length === 0) {
      throw new Error(`Invalid deployOrder entry: ${name}`);
    }
    const addr = placeholder ? zeroAddress : getCreateAddress({ from: deployer, nonce });
    constants[name] = addr;
    nonce += 1;
  }

  const external = config.constants ?? {};
  for (const [name, value] of Object.entries(external)) {
    constants[name] = normalizeAddress(value);
  }

  if (external.CREATOR) {
    const externalCreator = normalizeAddress(external.CREATOR);
    if (externalCreator.toLowerCase() !== deployer.toLowerCase()) {
      throw new Error(`CREATOR must match deployer (${deployer}); got ${externalCreator}`);
    }
  }
  constants.CREATOR = deployer;

  const order = [...deployOrder, ...Object.keys(external)];
  if (!order.includes("CREATOR")) order.push("CREATOR");
  const outputPath = toAbs(config.output ?? "contracts/DeployConstants.sol");
  const contents = renderSolidity(constants, order);

  fs.writeFileSync(outputPath, contents, "utf8");
  console.log(`Wrote ${outputPath}`);
}

main();
