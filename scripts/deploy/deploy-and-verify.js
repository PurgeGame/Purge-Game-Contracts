import fs from "node:fs";
import path from "node:path";
import hre from "hardhat";
import { getCreateAddress, isAddress } from "ethers";

const DEPLOY_ORDER = [
  "ICONS_32",
  "TROPHY_SVG_ASSETS",
  "GAME_MINT_MODULE",
  "GAME_JACKPOT_MODULE",
  "GAME_BOND_MODULE",
  "GAME_ENDGAME_MODULE",
  "DGNRS",
  "BONDS",
  "COIN",
  "VAULT",
  "AFFILIATE",
  "JACKPOTS",
  "QUESTS",
  "ICON_COLOR_REGISTRY",
  "RENDERER_REGULAR",
  "RENDERER_TROPHY_SVG",
  "RENDERER_TROPHY",
  "GAMEPIECE_RENDERER_ROUTER",
  "TROPHY_RENDERER_ROUTER",
  "TROPHIES",
  "GAMEPIECES",
  "GAME",
  "ADMIN"
];

const ALL_CONSTANTS = [...DEPLOY_ORDER, "STETH_TOKEN", "LINK_TOKEN", "CREATOR"];
const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";

const NETWORK_DEFAULTS = {
  mainnet: {
    STETH_TOKEN: "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84",
    LINK_TOKEN: "0x514910771AF9Ca656af840dff83E8264EcF986CA"
  },
  sepolia: {
    STETH_TOKEN: "0x3e3FE7dBc6B4C189E7128855dD526361c49b40Af",
    LINK_TOKEN: "0x779877A7B0D9E8603169DdbD7836e478b4624789"
  }
};

function parseArgs(argv) {
  const out = {};
  for (let i = 0; i < argv.length; i += 1) {
    const raw = argv[i];
    if (!raw.startsWith("--")) continue;
    const trimmed = raw.slice(2);
    const eqIdx = trimmed.indexOf("=");
    if (eqIdx !== -1) {
      const key = trimmed.slice(0, eqIdx);
      const value = trimmed.slice(eqIdx + 1);
      out[key] = value;
      continue;
    }
    const next = argv[i + 1];
    if (next && !next.startsWith("--")) {
      out[trimmed] = next;
      i += 1;
    } else {
      out[trimmed] = true;
    }
  }
  return out;
}

function requireAddress(label, value) {
  if (!value || typeof value !== "string" || !isAddress(value)) {
    throw new Error(`Invalid ${label} address: ${value}`);
  }
  return value;
}

function parseNonce(value) {
  if (value === undefined) return null;
  const n = Number.parseInt(value, 10);
  if (!Number.isInteger(n) || n < 0) {
    throw new Error(`Invalid startNonce: ${value}`);
  }
  return n;
}

function renderSolidity(constants) {
  const lines = [
    "// SPDX-License-Identifier: MIT",
    "pragma solidity ^0.8.26;",
    "",
    "// AUTO-GENERATED by scripts/deploy/deploy-and-verify.js",
    "// Do not edit by hand; regenerate via the script.",
    "library ContractAddresses {"
  ];

  for (const name of ALL_CONSTANTS) {
    const value = constants[name] || ZERO_ADDRESS;
    lines.push(`    address internal constant ${name} = ${value};`);
  }

  lines.push("}");
  lines.push("");
  return lines.join("\n");
}

async function deployWithCheck(factory, expected, label, args = []) {
  const contract = await factory.deploy(...args);
  await contract.waitForDeployment();
  const addr = await contract.getAddress();
  if (addr.toLowerCase() !== expected.toLowerCase()) {
    throw new Error(`${label} deployed at ${addr}, expected ${expected}`);
  }
  return contract;
}

async function main() {
  const args = parseArgs(process.argv.slice(2));
  if (args.help) {
    console.log(
      [
        "Usage:",
        "  node scripts/deploy/deploy-and-verify.js --deployer <address> --startNonce <n> --network sepolia|mainnet",
        "Options:",
        "  --deployer   Deployer EOA address (required)",
        "  --startNonce Starting nonce for the deployer (default: current signer nonce)",
        "  --network    Network preset for STETH/LINK (sepolia|mainnet)",
        "  --steth      Override STETH token address",
        "  --link       Override LINK token address",
        "  --output     Output path (default: contracts/ContractAddresses.sol)"
      ].join("\n")
    );
    return;
  }

  const { ethers, run } = hre;
  const [deployer] = await ethers.getSigners();
  const signerAddr = deployer.address;
  const deployerAddr = requireAddress("deployer", args.deployer);
  if (deployerAddr.toLowerCase() !== signerAddr.toLowerCase()) {
    throw new Error(`Signer ${signerAddr} does not match --deployer ${deployerAddr}`);
  }

  const currentNonce = await deployer.getNonce();
  const startNonce = parseNonce(args.startNonce) ?? currentNonce;
  if (startNonce !== currentNonce) {
    throw new Error(`Signer nonce ${currentNonce} does not match --startNonce ${startNonce}`);
  }

  const networkKey = (args.network || "").toLowerCase();
  const defaults = NETWORK_DEFAULTS[networkKey] || {};
  const steth = args.steth || defaults.STETH_TOKEN;
  const link = args.link || defaults.LINK_TOKEN;
  if (!steth || !link) {
    throw new Error("Missing STETH/LINK: provide --network or explicit --steth and --link.");
  }

  const expected = {};
  let nonce = startNonce;
  for (const name of DEPLOY_ORDER) {
    expected[name] = getCreateAddress({ from: deployerAddr, nonce });
    nonce += 1;
  }

  expected.STETH_TOKEN = requireAddress("steth", steth);
  expected.LINK_TOKEN = requireAddress("link", link);
  expected.CREATOR = deployerAddr;

  const output = args.output ? path.resolve(args.output) : path.resolve("contracts/ContractAddresses.sol");
  fs.mkdirSync(path.dirname(output), { recursive: true });
  fs.writeFileSync(output, renderSolidity(expected), "utf8");
  console.log(`Wrote ${output}`);

  await run("compile");

  const iconsPath = path.resolve("scripts/data/icons32Data.json");
  const iconsRaw = fs.readFileSync(iconsPath, "utf8");
  const iconsData = JSON.parse(iconsRaw);
  if (iconsData.paths?.length !== 33) throw new Error("icons32Data.json paths length mismatch");
  if (iconsData.symQ1?.length !== 8) throw new Error("icons32Data.json symQ1 length mismatch");
  if (iconsData.symQ2?.length !== 8) throw new Error("icons32Data.json symQ2 length mismatch");
  if (iconsData.symQ3?.length !== 8) throw new Error("icons32Data.json symQ3 length mismatch");

  for (const name of DEPLOY_ORDER) {
    console.log(`Deploying ${name} -> ${expected[name]}`);
    if (name === "ICONS_32") {
      const factory = await ethers.getContractFactory("contracts/Icons32Data.sol:Icons32Data", deployer);
      await deployWithCheck(factory, expected[name], name, [
        iconsData.paths,
        iconsData.diamond,
        iconsData.symQ1,
        iconsData.symQ2,
        iconsData.symQ3
      ]);
      continue;
    }
    if (name === "TROPHY_SVG_ASSETS") {
      const factory = await ethers.getContractFactory("contracts/TrophySvgAssets.sol:TrophySvgAssets", deployer);
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "GAME_MINT_MODULE") {
      const factory = await ethers.getContractFactory(
        "contracts/modules/DegenerusGameMintModule.sol:DegenerusGameMintModule",
        deployer
      );
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "GAME_JACKPOT_MODULE") {
      const factory = await ethers.getContractFactory(
        "contracts/modules/DegenerusGameJackpotModule.sol:DegenerusGameJackpotModule",
        deployer
      );
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "GAME_BOND_MODULE") {
      const factory = await ethers.getContractFactory(
        "contracts/modules/DegenerusGameBondModule.sol:DegenerusGameBondModule",
        deployer
      );
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "GAME_ENDGAME_MODULE") {
      const factory = await ethers.getContractFactory(
        "contracts/modules/DegenerusGameEndgameModule.sol:DegenerusGameEndgameModule",
        deployer
      );
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "DGNRS") {
      const factory = await ethers.getContractFactory("contracts/DegenerusBonds.sol:BondToken", deployer);
      await deployWithCheck(factory, expected[name], name); // No constructor args - all constants
      continue;
    }
    if (name === "BONDS") {
      const factory = await ethers.getContractFactory("contracts/DegenerusBonds.sol:DegenerusBonds", deployer);
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "VAULT") {
      const factory = await ethers.getContractFactory("contracts/DegenerusVault.sol:DegenerusVault", deployer);
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "COIN") {
      const factory = await ethers.getContractFactory("contracts/DegenerusCoin.sol:DegenerusCoin", deployer);
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "AFFILIATE") {
      const factory = await ethers.getContractFactory("contracts/DegenerusAffiliate.sol:DegenerusAffiliate", deployer);
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "JACKPOTS") {
      const factory = await ethers.getContractFactory("contracts/DegenerusJackpots.sol:DegenerusJackpots", deployer);
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "QUESTS") {
      const factory = await ethers.getContractFactory("contracts/DegenerusQuests.sol:DegenerusQuests", deployer);
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "ICON_COLOR_REGISTRY") {
      const factory = await ethers.getContractFactory("contracts/IconColorRegistry.sol:IconColorRegistry", deployer);
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "RENDERER_REGULAR") {
      const factory = await ethers.getContractFactory(
        "contracts/IconRendererRegular32.sol:IconRendererRegular32",
        deployer
      );
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "RENDERER_TROPHY_SVG") {
      const factory = await ethers.getContractFactory(
        "contracts/IconRendererTrophy32Svg.sol:IconRendererTrophy32Svg",
        deployer
      );
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "RENDERER_TROPHY") {
      const factory = await ethers.getContractFactory(
        "contracts/IconRendererTrophy32.sol:IconRendererTrophy32",
        deployer
      );
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "GAMEPIECE_RENDERER_ROUTER") {
      const factory = await ethers.getContractFactory(
        "contracts/GamepieceRendererRouter.sol:GamepieceRendererRouter",
        deployer
      );
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "TROPHY_RENDERER_ROUTER") {
      const factory = await ethers.getContractFactory(
        "contracts/TrophyRendererRouter.sol:TrophyRendererRouter",
        deployer
      );
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "TROPHIES") {
      const factory = await ethers.getContractFactory("contracts/DegenerusTrophies.sol:DegenerusTrophies", deployer);
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "GAMEPIECES") {
      const factory = await ethers.getContractFactory(
        "contracts/DegenerusGamepieces.sol:DegenerusGamepieces",
        deployer
      );
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "GAME") {
      const factory = await ethers.getContractFactory("contracts/DegenerusGame.sol:DegenerusGame", deployer);
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    if (name === "ADMIN") {
      const factory = await ethers.getContractFactory("contracts/DegenerusAdmin.sol:DegenerusAdmin", deployer);
      await deployWithCheck(factory, expected[name], name);
      continue;
    }
    throw new Error(`Unknown deploy target: ${name}`);
  }

  console.log("All deployments matched expected addresses.");
  console.log("VRF wiring still required via DegenerusAdmin.wireVrf().");
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
